# 브라우저 렌더링

브라우저 엔진은 렌더링 엔진이라고도 하며 브라우저의 렌더링을 처리한다.
자바스크립트 엔진은 스크립트를 해석하고 실행하는 엔진이다. 자바스크립트를 통해 DOM을 변경하거나 스타일을 바꾸면 브라우저 엔진은 다시 `reflow`, `repaint`를 해야 할 수 있다. 브라우저 엔진과 자바스크립트 엔진은 긴밀하게 연관이 있음.

**브라우저 엔진의 종류**

- 크롬: Blink
	- 자바스크립트 엔진은 v8엔진
- 사파리: WebKit
	- 자바스크립트 엔진 JavascriptCore
- 파이어폭스: Gecko
	- 자바스크립트 엔진 SpiderMonkey
- 엣지: Chromium기반의 Blink 엔진
	- 마이크로소프트가 엣지를 Chromium기반으로 전환

## 렌더링 과정

브라우저가 HTML, CSS, Javascript등을 화면에 그릴 때 다음과 같은 렌더링 과정을 거친다.

1. DOM 트리 생성
2. CSSOM 트리 생성
3. Javascript 실행
4. 렌더 트리 생성
5. 레이아웃 / 리플로우
6. 페인팅 / 리페인트
7. 컴포지팅

각각의 단계를 자세히 파보자.

### 1. DOM 트리 생성

브라우저가 HTML 파일을 받으면 이를 *파싱*하여 DOM(Document Object Model)트리를 만든다.
파서는 태그를 만나면 DOM 노드를 생성한다. 중첩태그는 부모-자식 관계의 노드로 표현된다. 파싱을 통해 브라우저가 이해할 수 있는 트리형태로 변환된다.

```html
<!DOCTYPE html>
<html>
	<head>
		<title>예시 페이지</title>
	</head>
	<body>
		<h1>안녕하세요</h1> <p>이것은 <span>예시</span> 입니다.</p>
	</body>
</html>
```

```text
# 트리 구조로 변환
Document
└── html
	├── head
	│ └── title
	│ └── "예시 페이지" (Text 노드)
	└── body
		├── h1
		│   └── "안녕하세요" (Text 노드)
		└── p
			├── "이것은 " (Text 노드)
			├── span
			│    └── "예시" (Text 노드)
			└── " 입니다." (Text 노드)
```

**DOM트리 생성 과정**

1. `바이트 -> 문자`: HTML파일의 바이트를 문자로 변환한다.
2. `토큰화(tokenization)`: 변환된 문자를 명세에 따라 **토큰** 으로 변환한다.
3. `렉싱(lexing)`: 토큰을 노드 객체로 변환
4. `DOM 구축`: 노드 객체를 트리 구조로 연결

브라우저는 전체 파일을 다운로드하지 않고도 DOM트리 구축을 시작한다. 이로 인해 큰 페이지에서도 사용자는 일부 콘텐츠를 빠르게 볼 수 있다. 파서는 인라인 스크립트나 동기적으로 로드되는 외부 스크립트를 만나면 파싱이 중단된다.

잦은 DOM조작은 성능 저하의 원인이 될 수 있다.
불필요한 DOM노드는 제거하여 메모리 누수를 방지해야 한다.

**shadow DOM**을 사용하면 캡슐화된 DOM트리를 만들 수 있다. 이는 스타일 충돌을 방지하고 컴포넌트 기반 개발을 용이하게 한다.
React와 같은 라이브러리는 **가상 DOM**을 사용해 실제 DOM조작을 최소화 한다. 

### 2. CSSOM 트리 생성

CSS를 파싱해 CSSOM(CSS Object Model) 트리를 만든다. 선택자과 스타일 규칙을 분석해 계층 구조로 변환한다. 상속과 계단식 규칙을 적용해 최종 스타일이 결정된다.

CSSOM트리는 CSS 규칙을 구조화한 트리로 CSS 파일, 인라인 스타일, 스타일태그를 모두 포함한 모든 스타일 규칙을 반영한다.

**CSSOM트리 구축 과정**

1. CSS 파일 다운로드
   - 브라우저가 HTML을 파싱하는 동안 스타일 관련 태그를 만나면 비동기적으로 CSS 파일을 다운로드 한다. DOM 파싱을 계속 진행된다.
2. CSS 파싱
	- 파일이 다운로드되면, 선택자(selector)와 선언(declaration)으로 나누어진 규칙을 파싱하고 브라우저가 이해할 수 있는 구조로 변환된다.
3. 규칙 해석 및 상속
	- 상속: 자식 요소는 부모 요소로 부터 상속되는 스타일을 받을 수 있다. (font-family는 상속되지만, margin은 상속되지 않는다.)
	- specificity: 선택자에 따라 우선순위가 달라진다.
  	- 인라인 스타일 1000점 / ID 100점 / 클래스 10점 / 태그 1점
		- !important > 인라인 스타일 > ID > class > 요소 선택자 순의 우선순위
	- cascading: 스타일이 충돌할 때는 케스케이딩 규칙에 따라 마지막으로 선언된 스타일이 적용된다.
4. 트리 구축
	- 모든 CSS 규칙이 파싱되고 우선순위가 정해지면, 브라우저는 CSSOM 트리를 구축한다. HTML요소에 대해 적용된 스타일 규칙이 CSSOM트리의 노드로서 포함된다.
5. 렌더 트리 생성
	- DOM트리와 결합하여 렌더 트리를 만든다. 렌더 트리는 실제로 화면에 표시된 요소와 스타일만 포함한다.
	- 렌더 트리가 완료되면 레이아웃 계산, 페인팅 등을 통해 최종 렌더링이 이루어진다.

### 3. Javascript 실행

기본적인 흐름에서는 파싱중에 `<script>`태그를 만나면 파싱이 일시 중지되고 해당 스크립트를 실행한다.  동기적 스크립트라고도 하며, 다운로드 & 실행이 이루어질 동안 파싱이 중지된다.
이 시간이 길어지게 된면 그만큼 렌더링을 지연시킬 수 있다.

`async`와  `defer`속성을 사용하여 비동기적 스크립트를 통해  로딩을 최적화 할 수 있다.

#### defer

`<script defer>`를 사용하면 DOM파싱이 완료된 후에 실행된다. (defer는 지연, 뒤로 미루다라는 뜻!) 렌더 트리가 완료된 후에 실행 되기 때문에 자바스크립트에 의해 렌더링이 지연되는 일을 방지할 수 있다.

다운로드는 비동기적으로 이루어지고 실행은 렌더트리 완료된 후.

#### async

`<script async>`는 자바스크립트를 비동기적으로 다운로드하고, 다운로드 완료 *즉시* 실행된다. 스크립트 실행이  DOM파싱과 상관없이 언제든 이루어지기 때문에 DOM에 의존하는 스크립트에는 사용하지 않는 것이 좋다.

주로 페이지와 독립적인 스크립트나 구글 애널리틱스처럼 페이지 로딩에 직접 영향이 없는 자원을 로드할때 사용할 수 있다.

### 4. 렌더 트리 생성

DOM과 CSSOM을 결합하여 렌더 트리를 만든다. **렌더 트리는 화면에 실제로 그려질 요소들만 포함하며, `display: none`과 같은 요소는 제외된다.**

### 5. 레이아웃 (리플로우)

렌더 트리를 기반으로 각 요소의 위치와 크기를 계산한다. 뷰포트 내에서의 상대적인 위치를 결정하게 된다. 이 과정을 **reflow**라고도 한다.

렌더 트리가 생성되면, 브라우저는 각 요소의 CSS 스타일, 컨텐츠, 부모 요소와의 관계를 고려해서 크기와 위치를 계산한다. 
이 과정에서 **박스모델 (box model)** 을 기반으로 각 요소의 width, height, padding, border, margin등의 값을 계산한다.

#### 레이아웃에 영향을 미치는 요소들

- CSS 스타일
	- position, float, display, flex, grid
	- flex, grid는 레이아웃 계산에 있어서 더 최적화된 알고리즘을 사용해 float나 inline-block레이아웃에 비해 성능이 좋으며 리플로우를 최소화한다.
- 자바스크립드에 의한 DOM 변경
- 윈도우 리사이징
	- 브라우저 창의 크기가 변경되면, 브라우저는 모든 요소의 크기와 위치를 다시 계산한다.

### 6. 페인팅 / 리페인트

레이아웃 정보를 바탕으로 픽셀(텍스트, 색상, 이미지, 테두리, 그림자등)을 화면에 그린다. 최신 브라우저에서는 이 과정이 여러 레이어로 나뉘어 처리된다.

### 7. 컴포지팅

여러 레이어를 최종적으로 합성하여 화면에 표시한다.
GPU가속을 활용해 성능을 최적화 한다. -> 이미 계산된 레이어들을 다시 그리지 않고, 단순히 합성만 하기 때문
`transform`, `opacity`, `filter` 등의 속성 변경은 컴포지팅 단계에서만 처리되기 때문에 효율적이다.

#### 컴포지팅 과정

1. 레이어 생성: 복잡한 애니메이션이나 transform, opacity와 같은 속성이 적용될 때 별도의 레이어로 분리된다.
	- transform, opacity, will-change
	- position: fixed, position: sticky
1. 레이어 페인팅: 각 레이어는 독립적으로 페인팅된다. 한 레이어가 변경되더라도 다른 레이어는 영향을 받지 않아 성능 최적화가 가능하다.
2. 합성: 모든 레이어들이 준비되면 최종적으로 하나의 이미지로 합성되어 화면에 출력된다. GPU를 사용해 빠르게 합성한다.

---

## CSS의 GPU vs CPU?

CPU는 주로 레이아웃 계산과 DOM 조작 같은 복잡한 연산 작업을 처리하고 GPU는 컴포지팅과 애니메이션 같은 그래픽 렌더링 작업을 처리한다.
성능 최적화를 위해서는 layout 관련 작업은 최소화하고, GPU가속이 가능한 속성을 사용한다.

### CPU 기반 렌더링

- DOM 조작이나 스타일 변경이 발생하면, 브라우저는 새로운 레이아웃을 계산하거나 다시 페인팅을 해야한다. 이때 CPU는 레이아웃 계산과 페인팅 작업을 처리한다. **reflow, replaint**
- width, height, padding, margin과 같은 레이아웃 관련 속성 변경은 **reflow**가 발생한다.

### GPU 기반 렌더링

- `transform`이나 애니메이션에서 주로 사용되는 속성들은 GPU를 활용해 더 빠르고 부드럽게 렌더링 된다.
- GPU는 lazy-painting이나 컴포지팅단계에서 사용된다.

---

## Reflow & Repaint

### Reflow

Reflow는 브라우저가 페이지내의 요소들의 크기와 위치를 다시 계산하는 과정이다.(위의 렌더링 단계에서 레이아웃과정이 다시 일어나는 것) *매우 비싼* 작업이기 때문에 성능에 큰 영향을 줄 수 있다. 

**왜 비싼가?**
한 요소에서 레이아웃 변경이 발생하면 그 요소뿐만 아니라 연관된 모든 자식 요소까지 레이아웃을 계산해야 하기 때문에 DOM 트리가 클수록 더 많은 자원을 소모한다. 
레이아웃관련 속성(width, height, margin, padding)을 변경하면 reflow가 발생하고 repaint가 필연적으로 따라온다.

### Repaint

리플로우 - 레이아웃 계산 - 이 완료된 후, 다시 화면에 그려지는 과정이다.
레이아웃에는 변화가 없지만 스타일이나 모양이 변경될 때 트리거 된다. (background-color, color, border, box-shadow, visibility등)

`visibility`는 repaint만 유발하지만, `display`는 reflow-repaint를 유발한다.
